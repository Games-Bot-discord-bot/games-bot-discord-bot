"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = void 0;
const WebhookError_1 = require("./WebhookError");
const Message_1 = require("./Message");
const centra = require('centra');
/**
 * Represents a webhook
 */
class Webhook {
    /**
     * Represents a new webhook
     * @param {URL} url Webhook-URL
     * @param {String} username Username of the webhook
     * @param {URL} avatarUrl URL to a avatar
     */
    constructor(url, username, avatarUrl) {
        this.url = url;
        this.username = username;
        this.avatarUrl = avatarUrl;
    }
    /**
     * Gets information about the webhook.
     * @return {Promise<APIWebhook>}
     */
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield centra(this.url, 'GET').send();
            if (res.statusCode !== 200)
                throw new WebhookError_1.WebhookError(JSON.parse(res.body.toString()));
            return JSON.parse(res.body.toString());
        });
    }
    /**
     * Creates a new message as the webhook
     * @param {String} content Content of this message
     * @param {APIEmbed} embeds Array of [embeds](https://discord-api-types.dev/api/discord-api-types-v10/interface/APIEmbed) attached to this message
     * @param {Object} allowedMentions  [Allowed-Mentions-Object](https://discord-api-types.dev/api/discord-api-types-v10/interface/APIAllowedMentions)
     * @param {Boolean} tts If enabled, discord will read out the messages to everyone who has this channel open
     * @param {Array} components  Array of [Message-Component-Action-Rows](https://discord-api-types.dev/api/discord-api-types-v10/interface/APIActionRowComponent). âš  Most components will only work, if the webhook is owned by an application.
     * @return {Promise<Message>} New message
     */
    send(content, embeds = [], allowedMentions = {}, tts = false, components = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield centra(this.url + '?wait=true', 'POST').body({
                content: content,
                username: this.username,
                avatar_url: this.avatarUrl,
                tts: tts,
                embeds: embeds,
                allowed_mentions: allowedMentions,
                components
            })
                .header('Content-Type', 'application/json')
                .send();
            if (res.statusCode !== 200)
                throw new WebhookError_1.WebhookError(JSON.parse(res.body.toString()));
            return new Message_1.Message(JSON.parse(res.body.toString()), this.url);
        });
    }
    /**
     * Edits this webhook object
     * @param {String} name New username of the webhook
     * @param {String} base64Avatar [Base64](https://en.wikipedia.org/wiki/Base64)-String of your image. If you don't know how to use this, please google Image to Base64 nodejs or File to Base 64 if you have an image file.
     * @return {Promise<void>}
     */
    edit(name, base64Avatar) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield centra(this.url, 'PATCH').body({
                name,
                avatar: base64Avatar ? `data:image/jpeg;base64,${base64Avatar}` : null
            })
                .header('Content-Type', 'application/json')
                .send();
            if (res.statusCode !== 200)
                throw new WebhookError_1.WebhookError(JSON.parse(res.body.toString()));
        });
    }
    /**
     * Deletes this webhook
     * @throws{WebhookError}
     * @return {Promise}
     */
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield centra(this.url, 'DELETE').send();
            if (res.statusCode !== 204)
                throw new WebhookError_1.WebhookError(JSON.parse(res.body.toString()));
        });
    }
    /**
     * Fetches a message by ID (including content)
     * @param {String} id ID of the message
     * @return {Promise<Message>} Message
     */
    fetchMessage(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield centra(this.url + `/messages/${id}`, 'GET')
                .send();
            if (res.statusCode !== 200)
                throw new WebhookError_1.WebhookError(JSON.parse(res.body.toString()));
            return new Message_1.Message(JSON.parse(res.body.toString()), this.url);
        });
    }
    /**
     * Resolves a message by ID (will not include any content of this message. Only use this if you want to edit or delete already send messages without having to fetch the message again
     * @param messageID
     * @return {Message}
     */
    resolveMessageID(messageID) {
        return new Message_1.Message({ id: messageID }, this.url);
    }
}
exports.Webhook = Webhook;
